import os
import json
import sys
import argparse


def detect_package_ecosystem(directory: str) -> str | None:
    """
    Detect the correct package ecosystem for a directory.
    Returns a tuple of (ecosystem_name, priority)
    Higher priority will override lower priority if multiple ecosystems found.
    """
    # Check for specific files with priority
    file_ecosystem_map: dict[str, tuple[str, int]] = {
        # Python ecosystem detection
        "uv.lock": ("uv", 100),  # Highest priority for Python
        "poetry.lock": ("pip", 90),
        "pyproject.toml": ("pip", 80),
        "requirements.txt": ("pip", 70),
        "setup.py": ("pip", 60),
        "Pipfile.lock": ("pip", 50),
        "Pipfile": ("pip", 40),
        # Go ecosystem detection
        "go.mod": ("gomod", 100),
        "go.sum": ("gomod", 90),
        # Node ecosystem detection
        "package-lock.json": ("npm", 100),
        "yarn.lock": ("npm", 90),
        "pnpm-lock.yaml": ("npm", 85),
        "package.json": ("npm", 80),
        "bun.lockb": ("bun", 100),
        # Docker ecosystem detection
        "Dockerfile": ("docker", 80),
        "docker-compose.yml": ("docker-compose", 100),
        "docker-compose.yaml": ("docker-compose", 100),
        # Ruby ecosystem detection
        "Gemfile": ("bundler", 90),
        "Gemfile.lock": ("bundler", 100),
        # PHP ecosystem detection
        "composer.json": ("composer", 90),
        "composer.lock": ("composer", 100),
        # Rust ecosystem detection
        "Cargo.toml": ("cargo", 90),
        "Cargo.lock": ("cargo", 100),
        # .NET ecosystem detection
        "packages.config": ("nuget", 100),
        "paket.lock": ("nuget", 90),
        "global.json": ("dotnet-sdk", 100),
        "Directory.Packages.props": ("nuget", 95),
        # Elixir ecosystem detection
        "mix.exs": ("mix", 90),
        "mix.lock": ("mix", 100),
        # Elm ecosystem detection
        "elm.json": ("elm", 90),
        "elm-package.json": ("elm", 100),
        # Gradle ecosystem detection
        "build.gradle": ("gradle", 90),
        "build.gradle.kts": ("gradle", 90),
        "gradle-wrapper.properties": ("gradle", 100),
        # Maven ecosystem detection
        "pom.xml": ("maven", 100),
        # Dart/Flutter ecosystem detection
        "pubspec.yaml": ("pub", 90),
        "pubspec.lock": ("pub", 100),
        # Swift ecosystem detection
        "Package.swift": ("swift", 100),
        # Terraform ecosystem detection
        "main.tf": ("terraform", 90),
        ".terraform.lock.hcl": ("terraform", 100),
        # Dev containers detection
        "devcontainer.json": ("devcontainers", 100),
        ".devcontainer.json": ("devcontainers", 90),
        # Git submodule detection
        ".gitmodules": ("gitsubmodule", 100),
    }
    found_ecosystems: list[tuple[str, int]] = []

    # Check for each file type
    for filename, (ecosystem, priority) in file_ecosystem_map.items():
        if os.path.exists(os.path.join(directory, filename)):
            found_ecosystems.append((ecosystem, priority))

    if not found_ecosystems:
        return None

    # Return the highest priority ecosystem
    return sorted(found_ecosystems, key=lambda x: x[1], reverse=True)[0][0]


def generate_dependabot_config(directory_matrix: dict[str, list[str]]) -> str:
    """
    Generate dependabot.yml configuration based on detected project types
    """
    directories: list[str] = directory_matrix.get("dir", [])

    # Map directories to ecosystems
    ecosystem_dirs: dict[str, list[str]] = {}

    for directory in directories:
        ecosystem = detect_package_ecosystem(directory)
        if ecosystem:
            if ecosystem not in ecosystem_dirs:
                ecosystem_dirs[ecosystem] = []
            ecosystem_dirs[ecosystem].append(directory)

    # Build dependabot.yml content
    config = """# This file was generated by https://github.com/fredrikaverpil/github
# Do not edit manually!

version: 2
updates:
  - package-ecosystem: "github-actions"
    directories: ["/", ".github/**/*.yml", ".github/**/*.yaml"]
    schedule:
      interval: "weekly"
      day: "monday"
    groups:
      github-actions:
        patterns: ["*"]
    open-pull-requests-limit: 10
    labels:
      - "dependencies"
"""

    # Add ecosystem-specific configurations
    for ecosystem, dirs in ecosystem_dirs.items():
        # Format directories as YAML list
        dir_entries = "\n".join(f"      - {d}" for d in dirs)

        config += f"""
  - package-ecosystem: "{ecosystem}"
    directories:
{dir_entries}
    schedule:
      interval: "weekly"
      day: "monday"
    groups:
      {ecosystem}-minor-patch:
        patterns: ["*"]
        update-types: ["minor", "patch"]
    open-pull-requests-limit: 10
    labels:
      - "dependencies"
"""

    return config


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate dependabot.yml configuration"
    )
    _ = parser.add_argument(
        "--matrix",
        required=True,
        help="JSON matrix of directories from find-dirs action",
    )
    _ = parser.add_argument(
        "--output",
        default=".github/dependabot.yml",
        help="Output file path (default: .github/dependabot.yml)",
    )
    args: argparse.Namespace = parser.parse_args()

    try:
        # Explicitly annotate args.matrix as str before passing to json.loads
        matrix_input: str = args.matrix
        matrix_data: dict[str, list[str]] = json.loads(matrix_input)
    except json.JSONDecodeError:
        print("Error: Invalid JSON matrix input", file=sys.stderr)
        return 1

    # Generate dependabot configuration
    config_content = generate_dependabot_config(matrix_data)

    # Create output directory if it doesn't exist
    output_path: str = args.output
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Write configuration to file
    with open(output_path, "w") as f:
        _ = f.write(config_content)

    print(f"Dependabot configuration generated at {output_path}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
