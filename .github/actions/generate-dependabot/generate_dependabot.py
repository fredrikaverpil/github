import os
import json
import sys
import argparse


def detect_package_ecosystems(directory: str) -> list[str]:
    """
    Detect all package ecosystems in a directory.
    Returns a list of detected ecosystem names.
    """
    # Map of file indicators to ecosystems
    file_ecosystem_map: dict[str, str] = {
        # Python ecosystem detection
        "uv.lock": "uv",
        # Go ecosystem detection
        "go.mod": "gomod",  # Only need go.mod, not go.sum
        # Node ecosystem detection
        "package.json": "npm",  # Primary specification file
        # Docker ecosystem detection
        "Dockerfile": "docker",
        "docker-compose.yml": "docker-compose",
        "docker-compose.yaml": "docker-compose",
        # Ruby ecosystem detection
        "Gemfile": "bundler",
        # PHP ecosystem detection
        "composer.json": "composer",
        # Rust ecosystem detection
        "Cargo.toml": "cargo",  # Only need Cargo.toml, not Cargo.lock
        # .NET ecosystem detection
        "packages.config": "nuget",
        "global.json": "dotnet-sdk",
        "Directory.Packages.props": "nuget",
        # Elixir ecosystem detection
        "mix.exs": "mix",
        # Elm ecosystem detection
        "elm.json": "elm",
        # Gradle ecosystem detection
        "build.gradle": "gradle",
        "build.gradle.kts": "gradle",
        # Maven ecosystem detection
        "pom.xml": "maven",
        # Dart/Flutter ecosystem detection
        "pubspec.yaml": "pub",
        # Swift ecosystem detection
        "Package.swift": "swift",
        # Terraform ecosystem detection
        "main.tf": "terraform",
        # Dev containers detection
        "devcontainer.json": "devcontainers",
        ".devcontainer.json": "devcontainers",
        # Git submodule detection
        ".gitmodules": "gitsubmodule",
    }

    # Set to track unique ecosystems
    found_ecosystems: set[str] = set()

    # Check for each file type
    for filename, ecosystem in file_ecosystem_map.items():
        if os.path.exists(os.path.join(directory, filename)):
            found_ecosystems.add(ecosystem)

    return list(found_ecosystems)


def generate_dependabot_config(directory_matrix: dict[str, list[str]]) -> str:
    """
    Generate dependabot.yml configuration based on detected project types
    """
    directories: list[str] = directory_matrix.get("dir", [])

    # Map directories to ecosystems
    ecosystem_dirs: dict[str, list[str]] = {}

    for directory in directories:
        ecosystems = detect_package_ecosystems(directory)
        for ecosystem in ecosystems:
            if ecosystem not in ecosystem_dirs:
                ecosystem_dirs[ecosystem] = []
            ecosystem_dirs[ecosystem].append(directory)

    # Build dependabot.yml content
    config = """# This file was generated by https://github.com/fredrikaverpil/github
# Do not edit manually!

version: 2
updates:
  - package-ecosystem: "github-actions"
    directories: ["/", ".github/actions/*/*.yml", ".github/actions/*/*.yaml"]
    schedule:
      interval: "weekly"
      day: "monday"
    groups:
      github-actions:
        patterns: ["*"]
    open-pull-requests-limit: 10
    labels:
      - "dependencies"
"""

    # Add ecosystem-specific configurations
    for ecosystem, dirs in ecosystem_dirs.items():
        # Format directories as YAML list
        dir_entries = "\n".join(f"      - {d}" for d in dirs)

        config += f"""
  - package-ecosystem: "{ecosystem}"
    directories:
{dir_entries}
    schedule:
      interval: "weekly"
      day: "monday"
    groups:
      {ecosystem}-minor-patch:
        patterns: ["*"]
        update-types: ["minor", "patch"]
    open-pull-requests-limit: 10
    labels:
      - "dependencies"
"""

    return config


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate dependabot.yml configuration"
    )
    _ = parser.add_argument(
        "--matrix",
        required=True,
        help="JSON matrix of directories from find-dirs action",
        type=str,
    )
    _ = parser.add_argument(
        "--output",
        default=".github/dependabot.yml",
        help="Output file path (default: .github/dependabot.yml)",
        type=str,
    )
    args: argparse.Namespace = parser.parse_args()

    try:
        # Explicitly annotate args.matrix as str before passing to json.loads
        matrix_input: str = args.matrix
        matrix_data: dict[str, list[str]] = json.loads(matrix_input)
    except json.JSONDecodeError:
        print("Error: Invalid JSON matrix input", file=sys.stderr)
        return 1

    # Generate dependabot configuration
    config_content = generate_dependabot_config(matrix_data)

    # Create output directory if it doesn't exist
    output_path: str = args.output
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Write configuration to file
    with open(output_path, "w") as f:
        _ = f.write(config_content)

    print(f"Dependabot configuration generated at {output_path}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
